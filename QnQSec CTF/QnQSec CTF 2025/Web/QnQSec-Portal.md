# QnQSec CTF 2025 — QnQSec Portal
- **Category:** Web
- **Tags:** JWT Forgery, SSTI, RCE
- Author: blk

---

## **1. Challenge Summary**

The challenge requires us to attack a web portal built with Flask. The objective is to gain access to the administrator area and retrieve the flag. The challenge provides the application's source code, which reveals that it uses a session and JWT-based authentication mechanism, along with a SQLite database for user storage.

---

## **2. Initial Analysis & Reconnaissance**

The first step is to analyze the `app.py` source code.

- **Authentication:** The application uses MD5 to hash user passwords.
- **JWT Secret:** The `JWT_SECRET` is generated by hashing a string containing the `Q_SECRET` environment variable, but this variable has a default value of `qnqsec-default`. This is a critical weakness.
- **Admin User:** A special user named `flag` exists. When logging in with this account, a JWT with `role: "admin"` is created. The MD5 hash of the `flag` user's password is provided but cannot be cracked by common tools.

---

## **3. The Vulnerability**

The primary vulnerability is a combination of two issues:

1. **Predictable JWT Secret:** Because the `JWT_SECRET` is generated from a default value, anyone with the source code can reproduce this secret. This allows for the forgery of any JWT, bypassing the authentication mechanism.
2. **Server-Side Template Injection (SSTI):** After gaining access to the `/admin` area with a forged JWT, the template rendering functionality does not properly sanitize input, leading to an SSTI vulnerability. An attacker can execute arbitrary code on the server.

---

## **4. Exploitation Steps**

1. **Calculate JWT Secret:** Based on the source code, I recalculated the `JWT_SECRET` using Python.
2. **Forge Admin JWT:** Using the calculated secret, I created a new JWT on jwt.io with the payload `{ "sub": "Aurelinth", "role": "admin" }`.
    
    <img width="1728" height="953" alt="image" src="https://github.com/user-attachments/assets/9c79fd0a-0327-4e89-8a80-7ecb63000482" />

    
3. **Access Admin Panel:** I replaced the `admin_jwt` cookie in my browser with the forged JWT and accessed the `/admin` page.
4. **Confirm SSTI:** I submitted the payload `{{7*7}}` into the template rendering form and received the result `49`, confirming the SSTI vulnerability.
    
   <img width="860" height="425" alt="image" src="https://github.com/user-attachments/assets/25d09fb1-7b47-41c0-9226-ff61e2f01eec" />
   
   <img width="731" height="213" alt="image" src="https://github.com/user-attachments/assets/cd8b8dd3-87ee-49a0-9bcf-be27ccba3fe6" />

    
5. **Escalate to RCE:** I used a more complex SSTI payload to execute OS commands, starting with `ls` to list files.
6. **Read the Flag:** After identifying the flag's location at `secret/flag.txt`, I used a final payload to read its contents.

---

## **5. Final Exploit / Payload**

The final payload submitted to the template rendering form on the `/admin` page:

Code snippet

`{{ self.__init__.__globals__.__builtins__.__import__('os').popen('cat secret/flag.txt').read() }}`

**Result:**

`QnQsec{b4efafeb4bd43c404e425ea6d664a0f6}`

---

## **6. Key Takeaways & Lessons Learned**

- **Lesson 1:** Never use default values for secret variables. This is one of the most common and dangerous configuration errors.
- **Lesson 2:** Always treat user input in template rendering functions as untrusted. SSTI vulnerabilities often lead directly to RCE, especially in Python/Flask environments.
- **Lesson 3:** Chaining vulnerabilities (Auth Bypass + SSTI) is a very realistic attack scenario. Patching a single vulnerability may not be sufficient if an attacker can find another path.

---

# TIẾNG VIỆT

## **1. Challenge Summary**

Thử thách yêu cầu chúng ta tấn công một cổng thông tin web được xây dựng bằng Flask. Mục tiêu là truy cập vào khu vực quản trị viên và lấy được cờ (flag). Thử thách cung cấp mã nguồn của ứng dụng, cho thấy ứng dụng sử dụng cơ chế xác thực dựa trên session và JWT, cùng với cơ sở dữ liệu SQLite để lưu trữ người dùng.

---

## **2. Initial Analysis & Reconnaissance**

Việc đầu tiên là phân tích mã nguồn `app.py`.

- **Xác thực:** Ứng dụng sử dụng MD5 để hash mật khẩu người dùng.
- **JWT Secret:** `JWT_SECRET` được tạo ra bằng cách hash một chuỗi có chứa biến môi trường `Q_SECRET`, nhưng biến này có giá trị mặc định là `qnqsec-default`. Đây là một điểm yếu nghiêm trọng.
- **Người dùng Admin:** Có một người dùng đặc biệt tên là `flag`. Khi đăng nhập với tài khoản này, JWT sẽ được tạo với `role: "admin"`. Hash MD5 của mật khẩu người dùng `flag` được cung cấp nhưng không thể crack bằng các công cụ thông thường.

---

## **3. The Vulnerability**

Lỗ hổng chính là sự kết hợp của hai vấn đề:

1. **JWT Secret có thể đoán được:** Do `JWT_SECRET` được tạo từ một giá trị mặc định, bất kỳ ai có mã nguồn đều có thể tái tạo lại secret này. Điều này cho phép giả mạo bất kỳ JWT nào và vượt qua cơ chế xác thực.
2. **Server-Side Template Injection (SSTI):** Sau khi truy cập được vào khu vực `/admin` bằng JWT giả mạo, chức năng render template không lọc đầu vào đúng cách, dẫn đến lỗ hổng SSTI. Kẻ tấn công có thể thực thi mã tùy ý trên máy chủ.

---

## **4. Exploitation Steps**

1. **Tính toán JWT Secret:** Dựa vào mã nguồn, ta tính toán lại `JWT_SECRET` bằng Python.
2. **Giả mạo JWT Admin:** Sử dụng secret đã tính toán, ta tạo một JWT mới trên jwt.io với payload `{ "sub": "Aurelinth", "role": "admin" }`.
3. **Truy cập Admin Panel:** Ta thay thế cookie `admin_jwt` trong trình duyệt bằng JWT giả mạo và truy cập vào trang `/admin`.
4. **Xác nhận SSTI:** Ta gửi payload `{{7*7}}` vào ô render template và nhận được kết quả là `49`, xác nhận lỗ hổng SSTI.
5. **Leo thang thành RCE:** Ta sử dụng một payload SSTI phức tạp hơn để thực thi lệnh trên hệ điều hành, bắt đầu bằng lệnh `ls` để liệt kê các file.
6. **Đọc Flag:** Sau khi xác định được vị trí của flag là `secret/flag.txt`, ta sử dụng payload cuối cùng để đọc nội dung file này.

---

## **5. Final Exploit / Payload**

Payload cuối cùng được gửi đến form render template trong trang `/admin`:

Code snippet

`{{ self.__init__.__globals__.__builtins__.__import__('os').popen('cat secret/flag.txt').read() }}`

**Kết quả:**

`QnQsec{b4efafeb4bd43c404e425ea6d664a0f6}`

---

## **6. Key Takeaways & Lessons Learned**

- **Lesson 1:** Không bao giờ sử dụng các giá trị mặc định cho các biến bí mật (secret). Đây là một trong những lỗi cấu hình phổ biến và nguy hiểm nhất.
- **Lesson 2:** Luôn phải coi đầu vào của người dùng trong các hàm render template là không đáng tin cậy. Lỗ hổng SSTI thường dẫn thẳng đến RCE, đặc biệt là trong các môi trường Python/Flask.
- **Lesson 3:** Việc xâu chuỗi các lỗ hổng (Auth Bypass + SSTI) là một kịch bản tấn công rất thực tế. Việc vá một lỗ hổng đơn lẻ có thể không đủ nếu kẻ tấn công có thể tìm ra một con đường khác.
